# Java大作业设计文档

## 支持三种游戏模式的国际象棋小游戏




## 一、作业选题

本来我原计划大作业选题是使用Java作为后端语言实现一款web软件，但因为我这学期的数据库课程也有类似的大作业，选这个题目的话有偷懒之嫌，所以我思考再三决定选择一个对我来说十分陌生的领域——Java GUI编程。至于具体内容，我选择了国际象棋这门游戏，它的规则并不复杂，但也不像五子棋那样简单，对于2000行左右的中等规模程序再合适不过了。



## 二、需求分析

1. 为了让游戏能够进行，至少需要实现：
   - 一个可视化的棋盘界面
   - 能通过鼠标点击正确移动棋子
   - 代码能判断棋子移动是否合法
   - 有将军、将死、和棋等判断逻辑
2. 为了让单独一个人也能玩，需要实现：
    - 一个具有较高水平，同时计算耗时不能太长的AI
3. 为了进一步提升使用体验，需要实现：
    - 合法棋子落点提示
    - 不合法操作提示
    - AI移动路径提示
    - 落棋即时渲染
    - 一些棋类游戏的基本操作，如悔棋操作
    - 开始新游戏操作
    - 支持双人对战等不同模式



## 三、总体设计

 ### 3.1 类图

![classMap](.\img\classMap.png)

### 3.2 总体运行逻辑

项目文件组织如下：

![image-20221007000314670](img\files.png)

其中piece软件包中是项目的核心代码，它实现了对棋子行棋可能性的列举。gui软件包是和用户界面相关的代码，其中的listener子软件包实现了对各类事件的监听与处理，Computer和Player类继承了Thread类，用于处理电脑AI和玩家的行棋操作。util软件包中存放各种工具类，包括AI决策类，棋盘类，事件枚举类等。当玩家点击屏幕时，listener软件包中的监听器首先监听到事件的发生，然后根据事件类型调用棋盘类的各种接口，棋盘类进一步调用各棋子类。事件处理完毕后，如果有棋子移动，则对用户界面的棋盘进行一次渲染。connection软件包则用于提供与外部AI的通信支持。

### 3.3 迭代一览

<img src="img/hist.png">



## 四、设计细节

### 4.1 底层逻辑设计

#### 4.1.1 棋子类设计

- 国际象棋共有6种棋子：卒（Pawn）、车（Rook）、马（Knight）、象（Bishop）、后（Queen）、王（King）。我为这六种棋子各种建立了一个类，它们都继承了``ChessPiece``类，便于不同类型棋子的统一存放与多态调用。
- 这些棋子类的核心属性包括在棋盘上的位置、是黑棋还是白棋；它们的核心方法是返回当前能移动到的所有位置。为了获得这些位置，包括但不限于需要考虑棋子自身移动规律、其他棋子的阻碍、移动后是否会导致本方王被将军、是否超出棋盘限制等因素。

#### 4.1.2 棋盘类设计

- 由于游戏中只可能存在一个棋盘，所以我将棋盘类设计为单例模式，其他类通过实例获取方法来获取棋盘。
- 棋盘类的核心属性是一个存放所有棋子对象的列表。为了对列表进行高效的访问，我将棋子在棋盘中的x、y坐标与其在列表中的索引值一一对应，具体来说，是：$index = 8 * (y - 1) + x - 1$。

- 棋盘类是本项目中最大的一个文件，有效代码长度近500行，主要的方法包括王相关状态判断、棋子移动、悔棋逻辑等。

#### 4.1.3 AI设计

##### 4.1.3.1 内置AI设计

- 这部分是我在整个项目中花时间最多的一部分，因为它不仅逻辑比较复杂，容易出现意想不到的bug，而且需要不断调试参数以达到最优，这就意味着要不断进行游戏来测试AI性能。
- 经过调研与实验，我选择了最大最小策略+剪枝+基于所在棋盘位置的价值判断来编写我的AI。
  - 所谓最大最小策略，就是在局中一方能够获得的最小收益最大化的策略。具体来说，如果黑方先走一步，然后白方再走一步。由于在博弈当中，白方所做的选择必然要让黑方收益最小化，那么对于黑方来说，最大最小策略就是在所有被白方最小化的收益中寻找最大值。我所设计的AI正是基于这种策略对接下来几步行棋进行模拟，从中找到（局部）最优解。
  - 最大最小策略的有效性是与模拟步数呈正相关的。经过试验，我发现当模拟步数为2时，AI所走的棋只是纯粹的趋利避害，没有丝毫大局思维。担当我将模拟步数增加到4时，每次模拟的时间就会长达十几二十秒。所以，我在最大最小策略的基础上引入了剪枝逻辑。具体来说，在遍历某一步黑方行棋时，记录之前已经遍历的所有行棋所取得的最大收益，在之后的模拟中，如果白方的某一步行棋使得收益小于之前所记录的最大收益，则直接跳过对这个分支的遍历，因为最优解显然不在这个分支中。引入剪枝之后，4步模拟平均时长减少到了2-3s，是一个合适的计算时间。
  - 为了判断不同行棋的优劣，需要量化不同局面下的棋子价值。我参考了维基百科上的[Simplified Evaluation Function](https://www.chessprogramming.org/Simplified_Evaluation_Function)棋子价值表模型，它为每种棋子建立了一个价值表，以位置为唯一依据判断棋子价值。对于整个棋盘，将黑棋价值乘1，白棋价值乘-1，各个棋子求和得到全局的价值，作为最大最小策略所需要最大化的对象。为了使之适配我的设计，我还对其进行了一些修改，包括引入负的空棋格价值等。
  - 经过调试，本AI已经达到了一个对于业余玩家来说中上的水平。
- 在模拟决策的过程中需要不断移动棋子，势必会对原棋盘造成破坏。所以我让``ChessPiece``类实现了``Cloneable``接口并重写了``Clone()``方法，在每次模拟之前调用``clone()``对当前棋盘状态进行一次深拷贝，然后在模拟结束后将此份拷贝赋给棋盘。
- 此外，我还尝试了使用蒙特卡洛树搜索来编写AI，决策有效性不如最大最小策略，但决策多样性高于它。所以我还是保留了对应接口在策略类中。

##### 4.1.3.2 外部连接AI设计

- 本部分AI使用的是github上的开源**sunfish**AI引擎。该AI软件使用命令行进行人机交互，棋子操作方式为输入棋子原坐标+目的地坐标（如f6g6），此外，该AI使用python语言编写，因此，为了实现项目与AI引擎的交互，就必须解决二者之间的通信。
- 经过分析与调研，我采用了``Runtime.getRuntime().exec()``启动AI主程序+TCP socket通信的方法实现对AI的调用。
- 为了实现TCP socket通信，我改写了AI引擎的主程序，在其``main``方法中建立一个TCP监听器，从监听器中获得行棋选择（统一为类似f6g6的格式），然后将其作为参数换掉原本从命令行中获得的参数。分析获得AI行棋之后，再将这个结果发送给客户端（也就是Java程序）。相对应的，Java端建立一个socket对象，然后通过它获得TCP输入流``InputStream``和TCP输出流``OutputStream``，当玩家进行一次行棋之后，将这次行棋转化为统一的格式，然后使用``out.write``输出字节码，接着调用``in.read``，线程进入阻塞状态等待python服务端传回信息。最后将统一编码转换回原格式即可。
- 为了让玩家能选择哪种AI进行游戏，在窗口创建之初生成一个``Jdialog``，让玩家执行选择AI引擎。如果玩家选择了内置AI，就调用相关函数关闭客户端和服务端的socket，防止资源被浪费。
- 在测试中我还发现，如果在游戏开始时的模式选择界面直接点叉的话，虽然表面上看起来游戏被关闭了，但实际上游戏进程还在后台运行，所以游戏使用的TCP端口就会一直被占用。为了解决这个问题，我在创建socket之前首先通过``Runtime.getRuntime().exec()``运行``netstat -ano``指令找到占用端口的进程pid，然后通过``taskkill /t /f /im pid``杀死对应进程，释放端口。

#### 4.1.4 AI、玩家双线程设计

- AI与玩家线程在游戏开始之初就被创建，当没有行棋需要进行时，它们都处于阻塞状态。当监听器获得玩家行棋信号时，先唤醒玩家线程进行行棋，然后唤醒AI线程决策后行棋。整个过程的并发控制在``ReentrantLock``+``Condition``的配合下完成。

- 其实在初期规划时我并没有想到需要这个设计。但当我完成AI编写实际测试时，我发现在我点击棋子完成行棋之后，GUI界面会一直卡着不变，直到AI完成决策之后才同时刷新我的行棋和AI的行棋。经过查询资料，我知道了，当一个监听器线程被唤醒之后，主线程会阻塞直到监听器线程完成操作进入wait状态。而界面的刷新正是由主线程完成的。所以，当监听器线程进行AI决策时，主线程就一直处于阻塞状态，无法进行渲染，严重影响游戏体验，正因为如此我才选择引入这个设计。出人意料的是，在这样修改之后，AI决策的速度似乎也快了一些。

#### 4.1.5 悔棋设计

- 悔棋的设计比较简单，在棋盘类中设置一个``history``列表，每次黑棋移动后将此时的棋盘状态深拷贝一份加入``history``中。在每次悔棋时，从列表尾部取出一份快照赋给棋盘的棋子列表即可。不过其中还是有很多细节需要注意。

#### 4.1.6 双人对战设计

- 本部分设计实现的基本思路是创建两个不同的``JFrame``窗口，两个窗口共用一个``Board``棋盘类，每个玩家操作一个窗口，并使用线程锁来防止线程冲突与一个玩家连续多次行棋。

- 本部分的麻烦之处在于黑方也会成为玩家，所以在AI对战中对白方玩家的提示同样应该应用于这个模式下的黑方玩家。但因为我之前在设计上考虑的不是很周到，有些地方的提示添加不是只是通过改变颜色就能完成。因此，为了使得原本的函数适配双人对战模式，我花了不少时间进行重构与调试。

- 基本运行逻辑如下：游戏开始时创建两个窗口，一个是白棋视角，另一个是黑棋视角。白方行棋后，操作``Board``使得内部棋子排列顺序改变，然后对两个窗口进行渲染，使得棋子的改变体现在GUI界面上。特别地，同AI对战一样，对方的行棋也会以蓝色边框的方式体现在己方的窗口上。紧接着改变``Board``内部的状态变量，将此时的状态标记为黑方行棋，于是黑方就可以进行操作，而白方进行的任何操作都会被忽略。如此循环。

- 为了提升游戏体验，我在菜单栏加入了一个当前行棋方标识，如图所示：

  <img src="/img/menu.png">

### 4.2 可视化操作界面设计

#### 4.2.1 概述

本项目使用Java awt抽象窗口工具包 + Swing GUI工具包编写可视化界面。界面主体是一个``JFrame``对象，内部含有一个``JPanel``和两个``JButton``（分别是悔棋按键和新游戏按键）。``JPanel``表现为一个棋盘，其中又有8*8个设计为棋格外观的``JButton``，每个``JButton``通过改变背景色来实现黑白棋格的展现，通过改变文字内容来实现棋子的展现，通过改变边框内容实现提示信息的展现。对于某些信息，如非法的行棋操作，软件会生成一个定时关闭的``JDialog``进行提示。

#### 4.2.2 展示

##### 4.2.2.1 对战展示

- 内置AI对战

  <iframe height=360 width=150 src="img/1.mp4">

- 外部AI对战

  <iframe height=360 width=150 src="img/2.mp4">

- 双人对战

  <iframe height=360 width=150 src="img/3.mp4">

##### 4.2.2.2 提示展示

- 合法行棋路径提示：
  <img src="img/1.png" style="zoom: 25%;" />
- AI行棋路径展示：
  <img src="img/2.png" style="zoom: 25%;" />

- 将军提示：
  <img src="img/3.png" style="zoom: 25%;" />

- 悔棋路径提示：
  <img src="img/4.png" style="zoom: 25%;" />

- 棋子无法移动提示：
  <img src="img/5.png" style="zoom: 25%;" />

- 棋子不存在提示：
  <img src="img/6.png" style="zoom: 25%;" />

- 非法行为提示：
  <img src="img/7.png" style="zoom: 25%;" />

- 将死提示：
  <img src="img/8.png" style="zoom: 25%;" />
